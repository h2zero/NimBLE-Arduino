<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NimBLE-Arduino: Chained Memory Buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NimBLE-Arduino<span id="projectnumber">&#160;2.1.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___o_s_mbuf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Chained Memory Buffers<div class="ingroups"><a class="el" href="group___o_s_kernel.html">OSKernel</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos__mbuf__pkthdr.html">os_mbuf_pkthdr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos__mbuf.html">os_mbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos__mqueue.html">os_mqueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6cac59130516e8c8bc98f27bb1d18a9e" id="r_ga6cac59130516e8c8bc98f27bb1d18a9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga6cac59130516e8c8bc98f27bb1d18a9e">OS_MBUF_PKTHDR</a>(__om)</td></tr>
<tr class="separator:ga6cac59130516e8c8bc98f27bb1d18a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753a06f73d0b8dc916969e9ae490c0ce" id="r_ga753a06f73d0b8dc916969e9ae490c0ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga753a06f73d0b8dc916969e9ae490c0ce">OS_MBUF_PKTHDR_TO_MBUF</a>(__hdr)&#160;&#160;&#160;     (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *)(void *)((uint8_t *)(__hdr) - sizeof(struct <a class="el" href="structos__mbuf.html">os_mbuf</a>))</td></tr>
<tr class="separator:ga753a06f73d0b8dc916969e9ae490c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae286e94341ed58ac3be7b7a3cd0f1c25" id="r_gae286e94341ed58ac3be7b7a3cd0f1c25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gae286e94341ed58ac3be7b7a3cd0f1c25">OS_MBUF_PKTLEN</a>(__om)&#160;&#160;&#160;(<a class="el" href="group___o_s_mbuf.html#ga6cac59130516e8c8bc98f27bb1d18a9e">OS_MBUF_PKTHDR</a>(__om)-&gt;omp_len)</td></tr>
<tr class="separator:gae286e94341ed58ac3be7b7a3cd0f1c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf84d7b323b20131da17c8bfed65674" id="r_ga4bf84d7b323b20131da17c8bfed65674"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga4bf84d7b323b20131da17c8bfed65674">OS_MBUF_DATA</a>(__om,  __type)&#160;&#160;&#160;     (__type) ((__om)-&gt;om_data)</td></tr>
<tr class="separator:ga4bf84d7b323b20131da17c8bfed65674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a70c33b992b2c96ddbbea7a8e13ac4c" id="r_ga6a70c33b992b2c96ddbbea7a8e13ac4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga6a70c33b992b2c96ddbbea7a8e13ac4c">OS_MBUF_USRHDR</a>(om)</td></tr>
<tr class="separator:ga6a70c33b992b2c96ddbbea7a8e13ac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab603a13e3de7d579605bce345e3c5101" id="r_gab603a13e3de7d579605bce345e3c5101"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gab603a13e3de7d579605bce345e3c5101">OS_MBUF_USRHDR_LEN</a>(om)&#160;&#160;&#160;    ((om)-&gt;om_pkthdr_len - sizeof (struct <a class="el" href="structos__mbuf__pkthdr.html">os_mbuf_pkthdr</a>))</td></tr>
<tr class="separator:gab603a13e3de7d579605bce345e3c5101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa645aa091541bcc590e1f7091a35a7d" id="r_gafa645aa091541bcc590e1f7091a35a7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gafa645aa091541bcc590e1f7091a35a7d">OS_MBUF_LEADINGSPACE</a>(__om)&#160;&#160;&#160;_os_mbuf_leadingspace(__om)</td></tr>
<tr class="separator:gafa645aa091541bcc590e1f7091a35a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bed008283a020a38886e68997b99239" id="r_ga6bed008283a020a38886e68997b99239"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga6bed008283a020a38886e68997b99239">OS_MBUF_TRAILINGSPACE</a>(__om)&#160;&#160;&#160;_os_mbuf_trailingspace(__om)</td></tr>
<tr class="separator:ga6bed008283a020a38886e68997b99239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga58e43a9a31ec5b87045c3fdac558c595" id="r_ga58e43a9a31ec5b87045c3fdac558c595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga58e43a9a31ec5b87045c3fdac558c595">os_mqueue_init</a> (struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *mq, ble_npl_event_fn *ev_cb, void *arg)</td></tr>
<tr class="separator:ga58e43a9a31ec5b87045c3fdac558c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09eae83fe37c58957e50e8c808a030d2" id="r_ga09eae83fe37c58957e50e8c808a030d2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga09eae83fe37c58957e50e8c808a030d2">os_mqueue_get</a> (struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *)</td></tr>
<tr class="separator:ga09eae83fe37c58957e50e8c808a030d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e4cb29efbe140680667e3c8e907fd3" id="r_gab6e4cb29efbe140680667e3c8e907fd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gab6e4cb29efbe140680667e3c8e907fd3">os_mqueue_put</a> (struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *, struct ble_npl_eventq *, struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *)</td></tr>
<tr class="separator:gab6e4cb29efbe140680667e3c8e907fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164e3f90cdee2692a85c249761ba001e" id="r_ga164e3f90cdee2692a85c249761ba001e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga164e3f90cdee2692a85c249761ba001e">os_msys_register</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *)</td></tr>
<tr class="separator:ga164e3f90cdee2692a85c249761ba001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37fae8ba05975e958dd7e30e4218a0f" id="r_gaa37fae8ba05975e958dd7e30e4218a0f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gaa37fae8ba05975e958dd7e30e4218a0f">os_msys_get</a> (uint16_t dsize, uint16_t leadingspace)</td></tr>
<tr class="separator:gaa37fae8ba05975e958dd7e30e4218a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa984a74000da6f436912a99821baeb9a" id="r_gaa984a74000da6f436912a99821baeb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gaa984a74000da6f436912a99821baeb9a">os_msys_reset</a> (void)</td></tr>
<tr class="separator:gaa984a74000da6f436912a99821baeb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcbeb3a8fc23a871ed4f1fed560ed4d" id="r_gadbcbeb3a8fc23a871ed4f1fed560ed4d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gadbcbeb3a8fc23a871ed4f1fed560ed4d">os_msys_get_pkthdr</a> (uint16_t dsize, uint16_t user_hdr_len)</td></tr>
<tr class="separator:gadbcbeb3a8fc23a871ed4f1fed560ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82ba13b28a45ee54405dd7c4d6ea013b" id="r_ga82ba13b28a45ee54405dd7c4d6ea013b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga82ba13b28a45ee54405dd7c4d6ea013b">os_msys_count</a> (void)</td></tr>
<tr class="separator:ga82ba13b28a45ee54405dd7c4d6ea013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b97336a5ab02260a304188374d345" id="r_gadf2b97336a5ab02260a304188374d345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gadf2b97336a5ab02260a304188374d345">os_msys_num_free</a> (void)</td></tr>
<tr class="separator:gadf2b97336a5ab02260a304188374d345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2895885c2f34a9582d2490558e782ff5" id="r_ga2895885c2f34a9582d2490558e782ff5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga2895885c2f34a9582d2490558e782ff5">os_mbuf_pool_init</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *, struct <a class="el" href="structos__mempool.html">os_mempool</a> *mp, uint16_t, uint16_t)</td></tr>
<tr class="separator:ga2895885c2f34a9582d2490558e782ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2165377acfdf5c1b0e025654019c96d8" id="r_ga2165377acfdf5c1b0e025654019c96d8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga2165377acfdf5c1b0e025654019c96d8">os_mbuf_get</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *omp, uint16_t)</td></tr>
<tr class="separator:ga2165377acfdf5c1b0e025654019c96d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa752273dde9dcd14d0b71a1fe43dcc98" id="r_gaa752273dde9dcd14d0b71a1fe43dcc98"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gaa752273dde9dcd14d0b71a1fe43dcc98">os_mbuf_get_pkthdr</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *omp, uint8_t pkthdr_len)</td></tr>
<tr class="separator:gaa752273dde9dcd14d0b71a1fe43dcc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b448c75e8c65f395a83b29160daa678" id="r_ga2b448c75e8c65f395a83b29160daa678"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga2b448c75e8c65f395a83b29160daa678">os_mbuf_dup</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *m)</td></tr>
<tr class="separator:ga2b448c75e8c65f395a83b29160daa678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f71d058f297d01c65d3364788942a4d" id="r_ga0f71d058f297d01c65d3364788942a4d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga0f71d058f297d01c65d3364788942a4d">os_mbuf_off</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int off, uint16_t *out_off)</td></tr>
<tr class="separator:ga0f71d058f297d01c65d3364788942a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a365a381016fb89b7b5d4acef5ddb3" id="r_ga71a365a381016fb89b7b5d4acef5ddb3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga71a365a381016fb89b7b5d4acef5ddb3">os_mbuf_len</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="memdesc:ga71a365a381016fb89b7b5d4acef5ddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of an mbuf chain.  <br /></td></tr>
<tr class="separator:ga71a365a381016fb89b7b5d4acef5ddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672d3e6990c4d8fe60046ee6cde32ac1" id="r_ga672d3e6990c4d8fe60046ee6cde32ac1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga672d3e6990c4d8fe60046ee6cde32ac1">os_mbuf_append</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *m, const void *, uint16_t)</td></tr>
<tr class="separator:ga672d3e6990c4d8fe60046ee6cde32ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66da7f4e54d6dbf4dc2d7531b68d7db0" id="r_ga66da7f4e54d6dbf4dc2d7531b68d7db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga66da7f4e54d6dbf4dc2d7531b68d7db0">os_mbuf_appendfrom</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *dst, const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *src, uint16_t src_off, uint16_t len)</td></tr>
<tr class="separator:ga66da7f4e54d6dbf4dc2d7531b68d7db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcbfe183bd88962d78017cc51c59ed2" id="r_ga2bcbfe183bd88962d78017cc51c59ed2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga2bcbfe183bd88962d78017cc51c59ed2">os_mbuf_free</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *mb)</td></tr>
<tr class="separator:ga2bcbfe183bd88962d78017cc51c59ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66de6a0a042c35435547a1df9534cc3f" id="r_ga66de6a0a042c35435547a1df9534cc3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga66de6a0a042c35435547a1df9534cc3f">os_mbuf_free_chain</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="separator:ga66de6a0a042c35435547a1df9534cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1379ba25e8dc203a84ad6fc21f2880e" id="r_gad1379ba25e8dc203a84ad6fc21f2880e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gad1379ba25e8dc203a84ad6fc21f2880e">os_mbuf_adj</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *mp, int req_len)</td></tr>
<tr class="separator:gad1379ba25e8dc203a84ad6fc21f2880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d238e8abd1a459c2daf8fe814e13d4" id="r_gac5d238e8abd1a459c2daf8fe814e13d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gac5d238e8abd1a459c2daf8fe814e13d4">os_mbuf_cmpf</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int off, const void *data, int len)</td></tr>
<tr class="separator:gac5d238e8abd1a459c2daf8fe814e13d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d6f4ce57b2c5c7b619831689f519f1" id="r_ga11d6f4ce57b2c5c7b619831689f519f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga11d6f4ce57b2c5c7b619831689f519f1">os_mbuf_cmpm</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om1, uint16_t offset1, const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om2, uint16_t offset2, uint16_t len)</td></tr>
<tr class="separator:ga11d6f4ce57b2c5c7b619831689f519f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78630bc340b54e3ca2b788acefa4005" id="r_gae78630bc340b54e3ca2b788acefa4005"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gae78630bc340b54e3ca2b788acefa4005">os_mbuf_prepend</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int len)</td></tr>
<tr class="separator:gae78630bc340b54e3ca2b788acefa4005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abfa49365ebfc92d5846e40825c8174" id="r_ga7abfa49365ebfc92d5846e40825c8174"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga7abfa49365ebfc92d5846e40825c8174">os_mbuf_prepend_pullup</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t len)</td></tr>
<tr class="separator:ga7abfa49365ebfc92d5846e40825c8174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e87037857c05e8a9379bb2889947854" id="r_ga5e87037857c05e8a9379bb2889947854"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga5e87037857c05e8a9379bb2889947854">os_mbuf_copyinto</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int off, const void *src, int len)</td></tr>
<tr class="separator:ga5e87037857c05e8a9379bb2889947854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ab8ccc2730629ca0dd8c5190575213" id="r_ga65ab8ccc2730629ca0dd8c5190575213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga65ab8ccc2730629ca0dd8c5190575213">os_mbuf_concat</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *first, struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *second)</td></tr>
<tr class="separator:ga65ab8ccc2730629ca0dd8c5190575213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b480043e6c246f6b94aa5da2d0a6739" id="r_ga4b480043e6c246f6b94aa5da2d0a6739"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga4b480043e6c246f6b94aa5da2d0a6739">os_mbuf_extend</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t len)</td></tr>
<tr class="separator:ga4b480043e6c246f6b94aa5da2d0a6739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad029706670ebb678ee5857143e04a7c4" id="r_gad029706670ebb678ee5857143e04a7c4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gad029706670ebb678ee5857143e04a7c4">os_mbuf_pullup</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t len)</td></tr>
<tr class="separator:gad029706670ebb678ee5857143e04a7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a9b5d03c2c263a455b6f758e65be2e" id="r_ga07a9b5d03c2c263a455b6f758e65be2e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga07a9b5d03c2c263a455b6f758e65be2e">os_mbuf_trim_front</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="separator:ga07a9b5d03c2c263a455b6f758e65be2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e6acfb8702f5333567f758f620e1f3" id="r_gaa5e6acfb8702f5333567f758f620e1f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#gaa5e6acfb8702f5333567f758f620e1f3">os_mbuf_widen</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t off, uint16_t len)</td></tr>
<tr class="separator:gaa5e6acfb8702f5333567f758f620e1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c014039fc115f26d01f723dd4c77412" id="r_ga0c014039fc115f26d01f723dd4c77412"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mbuf.html#ga0c014039fc115f26d01f723dd4c77412">os_mbuf_pack_chains</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *m1, struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *m2)</td></tr>
<tr class="separator:ga0c014039fc115f26d01f723dd4c77412"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4bf84d7b323b20131da17c8bfed65674" name="ga4bf84d7b323b20131da17c8bfed65674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf84d7b323b20131da17c8bfed65674">&#9670;&#160;</a></span>OS_MBUF_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_DATA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__om, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;     (__type) ((__om)-&gt;om_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the data of a mbuf, and cast it to type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__om</td><td>The mbuf to access, and cast </td></tr>
    <tr><td class="paramname">__type</td><td>The type to cast it to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa645aa091541bcc590e1f7091a35a7d" name="gafa645aa091541bcc590e1f7091a35a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa645aa091541bcc590e1f7091a35a7d">&#9670;&#160;</a></span>OS_MBUF_LEADINGSPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_LEADINGSPACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__om</td><td>)</td>
          <td>&#160;&#160;&#160;_os_mbuf_leadingspace(__om)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the leading space (space at the beginning) of the mbuf. Works on both packet header, and regular mbufs, as it accounts for the additional space allocated to the packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__omp</td><td>Is the mbuf pool (which contains packet header length.) </td></tr>
    <tr><td class="paramname">__om</td><td>Is the mbuf in that pool to get the leadingspace for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of leading space available in the mbuf </dd></dl>

</div>
</div>
<a id="ga6cac59130516e8c8bc98f27bb1d18a9e" name="ga6cac59130516e8c8bc98f27bb1d18a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cac59130516e8c8bc98f27bb1d18a9e">&#9670;&#160;</a></span>OS_MBUF_PKTHDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_PKTHDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__om</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<span class="keyword">struct </span><a class="code hl_struct" href="structos__mbuf__pkthdr.html">os_mbuf_pkthdr</a> *)     \</div>
<div class="line">    (<span class="keywordtype">void</span> *)((uint8_t *)&amp;(__om)-&gt;om_data + <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code hl_struct" href="structos__mbuf.html">os_mbuf</a>)))</div>
<div class="ttc" id="astructos__mbuf__pkthdr_html"><div class="ttname"><a href="structos__mbuf__pkthdr.html">os_mbuf_pkthdr</a></div><div class="ttdef"><b>Definition</b> os_mbuf.h:70</div></div>
<div class="ttc" id="astructos__mbuf_html"><div class="ttname"><a href="structos__mbuf.html">os_mbuf</a></div><div class="ttdef"><b>Definition</b> os_mbuf.h:86</div></div>
</div><!-- fragment --><p>Get a packet header pointer given an mbuf pointer </p>

</div>
</div>
<a id="ga753a06f73d0b8dc916969e9ae490c0ce" name="ga753a06f73d0b8dc916969e9ae490c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga753a06f73d0b8dc916969e9ae490c0ce">&#9670;&#160;</a></span>OS_MBUF_PKTHDR_TO_MBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_PKTHDR_TO_MBUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__hdr</td><td>)</td>
          <td>&#160;&#160;&#160;     (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *)(void *)((uint8_t *)(__hdr) - sizeof(struct <a class="el" href="structos__mbuf.html">os_mbuf</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a mbuf packet header pointer, return a pointer to the mbuf </p>

</div>
</div>
<a id="gae286e94341ed58ac3be7b7a3cd0f1c25" name="gae286e94341ed58ac3be7b7a3cd0f1c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae286e94341ed58ac3be7b7a3cd0f1c25">&#9670;&#160;</a></span>OS_MBUF_PKTLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_PKTLEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__om</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group___o_s_mbuf.html#ga6cac59130516e8c8bc98f27bb1d18a9e">OS_MBUF_PKTHDR</a>(__om)-&gt;omp_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the length of an entire mbuf chain. The specified mbuf must have a packet header. </p>

</div>
</div>
<a id="ga6bed008283a020a38886e68997b99239" name="ga6bed008283a020a38886e68997b99239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bed008283a020a38886e68997b99239">&#9670;&#160;</a></span>OS_MBUF_TRAILINGSPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_TRAILINGSPACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__om</td><td>)</td>
          <td>&#160;&#160;&#160;_os_mbuf_trailingspace(__om)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the trailing space (space at the end) of the mbuf. Works on both packet header and regular mbufs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__omp</td><td>The mbuf pool for this mbuf </td></tr>
    <tr><td class="paramname">__om</td><td>Is the mbuf in that pool to get trailing space for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of trailing space available in the mbuf </dd></dl>

</div>
</div>
<a id="ga6a70c33b992b2c96ddbbea7a8e13ac4c" name="ga6a70c33b992b2c96ddbbea7a8e13ac4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a70c33b992b2c96ddbbea7a8e13ac4c">&#9670;&#160;</a></span>OS_MBUF_USRHDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_USRHDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">om</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<span class="keywordtype">void</span> *)((uint8_t *)om + <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code hl_struct" href="structos__mbuf.html">os_mbuf</a>) +  \</div>
<div class="line">             sizeof (struct <a class="code hl_struct" href="structos__mbuf__pkthdr.html">os_mbuf_pkthdr</a>))</div>
</div><!-- fragment --><p>Access the "user header" in the head of an mbuf chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>Pointer to the head of an mbuf chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab603a13e3de7d579605bce345e3c5101" name="gab603a13e3de7d579605bce345e3c5101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab603a13e3de7d579605bce345e3c5101">&#9670;&#160;</a></span>OS_MBUF_USRHDR_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MBUF_USRHDR_LEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">om</td><td>)</td>
          <td>&#160;&#160;&#160;    ((om)-&gt;om_pkthdr_len - sizeof (struct <a class="el" href="structos__mbuf__pkthdr.html">os_mbuf_pkthdr</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the length of the user header in an mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>Pointer to the mbuf to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1379ba25e8dc203a84ad6fc21f2880e" name="gad1379ba25e8dc203a84ad6fc21f2880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1379ba25e8dc203a84ad6fc21f2880e">&#9670;&#160;</a></span>os_mbuf_adj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mbuf_adj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>req_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust the length of a mbuf, trimming either from the head or the tail of the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mbuf chain to adjust </td></tr>
    <tr><td class="paramname">req_len</td><td>The length to trim from the mbuf. If positive, trims from the head of the mbuf, if negative, trims from the tail of the mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga672d3e6990c4d8fe60046ee6cde32ac1" name="ga672d3e6990c4d8fe60046ee6cde32ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672d3e6990c4d8fe60046ee6cde32ac1">&#9670;&#160;</a></span>os_mbuf_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append data onto a mbuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf to append the data onto </td></tr>
    <tr><td class="paramname">data</td><td>The data to append onto the mbuf </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and an error code on failure </dd></dl>

</div>
</div>
<a id="ga66da7f4e54d6dbf4dc2d7531b68d7db0" name="ga66da7f4e54d6dbf4dc2d7531b68d7db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66da7f4e54d6dbf4dc2d7531b68d7db0">&#9670;&#160;</a></span>os_mbuf_appendfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_appendfrom </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>src_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from one mbuf and appends it to another. On error, the specified data range may be partially appended. Neither mbuf is required to contain an mbuf packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The mbuf to append to. </td></tr>
    <tr><td class="paramname">src</td><td>The mbuf to copy data from. </td></tr>
    <tr><td class="paramname">src_off</td><td>The absolute offset within the source mbuf chain to read from. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; OS_EINVAL if the specified range extends beyond the end of the source mbuf chain. </dd></dl>

</div>
</div>
<a id="gac5d238e8abd1a459c2daf8fe814e13d4" name="gac5d238e8abd1a459c2daf8fe814e13d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d238e8abd1a459c2daf8fe814e13d4">&#9670;&#160;</a></span>os_mbuf_cmpf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_cmpf </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a memory compare of the specified region of an mbuf chain against a flat buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The start of the mbuf chain to compare. </td></tr>
    <tr><td class="paramname">off</td><td>The offset within the mbuf chain to start the comparison. </td></tr>
    <tr><td class="paramname">data</td><td>The flat buffer to compare. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the flat buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both memory regions are identical; A memcmp return code if there is a mismatch; INT_MAX if the mbuf is too short. </dd></dl>

</div>
</div>
<a id="ga11d6f4ce57b2c5c7b619831689f519f1" name="ga11d6f4ce57b2c5c7b619831689f519f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d6f4ce57b2c5c7b619831689f519f1">&#9670;&#160;</a></span>os_mbuf_cmpm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_cmpm </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the contents of two mbuf chains. The ranges of the two chains to be compared are specified via the two offset parameters and the len parameter. Neither mbuf chain is required to contain a packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om1</td><td>The first mbuf chain to compare. </td></tr>
    <tr><td class="paramname">offset1</td><td>The absolute offset within om1 at which to start the comparison. </td></tr>
    <tr><td class="paramname">om2</td><td>The second mbuf chain to compare. </td></tr>
    <tr><td class="paramname">offset2</td><td>The absolute offset within om2 at which to start the comparison. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both mbuf segments are identical; A memcmp() return code if the segment contents differ; INT_MAX if a specified range extends beyond the end of its corresponding mbuf chain. </dd></dl>

</div>
</div>
<a id="ga65ab8ccc2730629ca0dd8c5190575213" name="ga65ab8ccc2730629ca0dd8c5190575213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65ab8ccc2730629ca0dd8c5190575213">&#9670;&#160;</a></span>os_mbuf_concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mbuf_concat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches a second mbuf chain onto the end of the first. If the first chain contains a packet header, the header's length is updated. If the second chain has a packet header, its header is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The mbuf chain being attached to. </td></tr>
    <tr><td class="paramname">second</td><td>The mbuf chain that gets attached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e87037857c05e8a9379bb2889947854" name="ga5e87037857c05e8a9379bb2889947854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e87037857c05e8a9379bb2889947854">&#9670;&#160;</a></span>os_mbuf_copyinto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_copyinto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the contents of a flat buffer into an mbuf chain, starting at the specified destination offset. If the mbuf is too small for the source data, it is extended as necessary. If the destination mbuf contains a packet header, the header length is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to allocate from. </td></tr>
    <tr><td class="paramname">om</td><td>The mbuf chain to copy into. </td></tr>
    <tr><td class="paramname">off</td><td>The offset within the chain to copy to. </td></tr>
    <tr><td class="paramname">src</td><td>The source buffer to copy from. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; nonzero on failure. </dd></dl>

</div>
</div>
<a id="ga2b448c75e8c65f395a83b29160daa678" name="ga2b448c75e8c65f395a83b29160daa678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b448c75e8c65f395a83b29160daa678">&#9670;&#160;</a></span>os_mbuf_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_dup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicate a chain of mbufs. Return the start of the duplicated chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to duplicate out of </td></tr>
    <tr><td class="paramname">om</td><td>The mbuf chain to duplicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new chain of mbufs </dd></dl>

</div>
</div>
<a id="ga4b480043e6c246f6b94aa5da2d0a6739" name="ga4b480043e6c246f6b94aa5da2d0a6739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b480043e6c246f6b94aa5da2d0a6739">&#9670;&#160;</a></span>os_mbuf_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * os_mbuf_extend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the length of an mbuf chain by the specified amount. If there is not sufficient room in the last buffer, a new buffer is allocated and appended to the chain. It is an error to request more data than can fit in a single buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td></td></tr>
    <tr><td class="paramname">om</td><td>The head of the chain to extend. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to extend by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new data on success; NULL on failure. </dd></dl>

</div>
</div>
<a id="ga2bcbfe183bd88962d78017cc51c59ed2" name="ga2bcbfe183bd88962d78017cc51c59ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bcbfe183bd88962d78017cc51c59ed2">&#9670;&#160;</a></span>os_mbuf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a mbuf back to the pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The Mbuf pool to release back to </td></tr>
    <tr><td class="paramname">om</td><td>The Mbuf to release back to the pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="ga66de6a0a042c35435547a1df9534cc3f" name="ga66de6a0a042c35435547a1df9534cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66de6a0a042c35435547a1df9534cc3f">&#9670;&#160;</a></span>os_mbuf_free_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_free_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a chain of mbufs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to free the chain of mbufs into </td></tr>
    <tr><td class="paramname">om</td><td>The starting mbuf of the chain to free back into the pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="ga2165377acfdf5c1b0e025654019c96d8" name="ga2165377acfdf5c1b0e025654019c96d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2165377acfdf5c1b0e025654019c96d8">&#9670;&#160;</a></span>os_mbuf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"><em>omp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>leadingspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an mbuf from the mbuf pool. The mbuf is allocated, and initialized prior to being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to return the packet from </td></tr>
    <tr><td class="paramname">leadingspace</td><td>The amount of leadingspace to put before the data section by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized mbuf on success, and NULL on failure. </dd></dl>

</div>
</div>
<a id="gaa752273dde9dcd14d0b71a1fe43dcc98" name="gaa752273dde9dcd14d0b71a1fe43dcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa752273dde9dcd14d0b71a1fe43dcc98">&#9670;&#160;</a></span>os_mbuf_get_pkthdr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_get_pkthdr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"><em>omp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pkthdr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new packet header mbuf out of the <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to allocate out of </td></tr>
    <tr><td class="paramname">user_pkthdr_len</td><td>The packet header length to reserve for the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A freshly allocated mbuf on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ga71a365a381016fb89b7b5d4acef5ddb3" name="ga71a365a381016fb89b7b5d4acef5ddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a365a381016fb89b7b5d4acef5ddb3">&#9670;&#160;</a></span>os_mbuf_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t os_mbuf_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the length of an mbuf chain. </p>
<p>Calculates the length of an mbuf chain. If the mbuf contains a packet header, you should use <code><a class="el" href="group___o_s_mbuf.html#gae286e94341ed58ac3be7b7a3cd0f1c25">OS_MBUF_PKTLEN()</a></code> as a more efficient alternative to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length, in bytes, of the provided mbuf chain. </dd></dl>

</div>
</div>
<a id="ga0f71d058f297d01c65d3364788942a4d" name="ga0f71d058f297d01c65d3364788942a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f71d058f297d01c65d3364788942a4d">&#9670;&#160;</a></span>os_mbuf_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_off </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>out_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the specified absolute offset within an mbuf chain. The offset can be one past than the total length of the chain, but no greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The start of the mbuf chain to seek within. </td></tr>
    <tr><td class="paramname">off</td><td>The absolute address to find. </td></tr>
    <tr><td class="paramname">out_off</td><td>On success, this points to the relative offset within the returned mbuf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mbuf containing the specified offset on success. NULL if the specified offset is out of bounds. </dd></dl>

</div>
</div>
<a id="ga0c014039fc115f26d01f723dd4c77412" name="ga0c014039fc115f26d01f723dd4c77412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c014039fc115f26d01f723dd4c77412">&#9670;&#160;</a></span>os_mbuf_pack_chains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_pack_chains </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a single chained mbuf from m1 and m2 utilizing all the available buffer space in all mbufs in the resulting chain. In other words, ensures there is no leading space in any mbuf in the resulting chain and trailing space only in the last mbuf in the chain. Mbufs from either chain may be freed if not needed. No mbufs are allocated. Note that mbufs from m2 are added to the end of m1. If m1 has a packet header, it is retained and length updated. If m2 has a packet header it is discarded. If m1 is NULL, NULL is returned and m2 is left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>Pointer to first mbuf chain to pack </td></tr>
    <tr><td class="paramname">m2</td><td>Pointer to second mbuf chain to pack</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>struct os_mbuf* Pointer to resulting mbuf chain </dd></dl>

</div>
</div>
<a id="ga2895885c2f34a9582d2490558e782ff5" name="ga2895885c2f34a9582d2490558e782ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2895885c2f34a9582d2490558e782ff5">&#9670;&#160;</a></span>os_mbuf_pool_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_pool_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"><em>omp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mempool.html">os_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nbufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a pool of mbufs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to initialize </td></tr>
    <tr><td class="paramname">mp</td><td>The memory pool that will hold this mbuf pool </td></tr>
    <tr><td class="paramname">buf_len</td><td>The length of the buffer itself. </td></tr>
    <tr><td class="paramname">nbufs</td><td>The number of buffers in the pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure. </dd></dl>

</div>
</div>
<a id="gae78630bc340b54e3ca2b788acefa4005" name="gae78630bc340b54e3ca2b788acefa4005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae78630bc340b54e3ca2b788acefa4005">&#9670;&#160;</a></span>os_mbuf_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_prepend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the length of an mbuf chain by adding data to the front. If there is insufficient room in the leading mbuf, additional mbufs are allocated and prepended as necessary. If this function fails to allocate an mbuf, the entire chain is freed.</p>
<p>The specified mbuf chain does not need to contain a packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to allocate from. </td></tr>
    <tr><td class="paramname">om</td><td>The head of the mbuf chain. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new head of the chain on success; NULL on failure. </dd></dl>

</div>
</div>
<a id="ga7abfa49365ebfc92d5846e40825c8174" name="ga7abfa49365ebfc92d5846e40825c8174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abfa49365ebfc92d5846e40825c8174">&#9670;&#160;</a></span>os_mbuf_prepend_pullup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_prepend_pullup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends a chunk of empty data to the specified mbuf chain and ensures the chunk is contiguous. If either operation fails, the specified mbuf chain is freed and NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf chain to prepend to. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to prepend and pullup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified mbuf on success; NULL on failure (and the mbuf chain is freed). </dd></dl>

</div>
</div>
<a id="gad029706670ebb678ee5857143e04a7c4" name="gad029706670ebb678ee5857143e04a7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad029706670ebb678ee5857143e04a7c4">&#9670;&#160;</a></span>os_mbuf_pullup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_pullup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rearrange a mbuf chain so that len bytes are contiguous, and in the data area of an mbuf (so that <a class="el" href="group___o_s_mbuf.html#ga4bf84d7b323b20131da17c8bfed65674">OS_MBUF_DATA()</a> will work on a structure of size len.) Returns the resulting mbuf chain on success, free's it and returns NULL on failure.</p>
<p>If there is room, it will add up to "max_protohdr - len" extra bytes to the contiguous region, in an attempt to avoid being called next time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to take the mbufs out of </td></tr>
    <tr><td class="paramname">om</td><td>The mbuf chain to make contiguous </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes in the chain to make contiguous</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contiguous mbuf chain on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ga07a9b5d03c2c263a455b6f758e65be2e" name="ga07a9b5d03c2c263a455b6f758e65be2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a9b5d03c2c263a455b6f758e65be2e">&#9670;&#160;</a></span>os_mbuf_trim_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mbuf_trim_front </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes and frees empty mbufs from the front of a chain. If the chain contains a packet header, it is preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf chain to trim.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The head of the trimmed mbuf chain. </dd></dl>

</div>
</div>
<a id="gaa5e6acfb8702f5333567f758f620e1f3" name="gaa5e6acfb8702f5333567f758f620e1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5e6acfb8702f5333567f758f620e1f3">&#9670;&#160;</a></span>os_mbuf_widen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_widen </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the length of an mbuf chain by inserting a gap at the specified offset. The contents of the gap are indeterminate. If the mbuf chain contains a packet header, its total length is increased accordingly.</p>
<p>This function never frees the provided mbuf chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf chain to widen. </td></tr>
    <tr><td class="paramname">off</td><td>The offset at which to insert the gap. </td></tr>
    <tr><td class="paramname">len</td><td>The size of the gap to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; SYS_[...] error code on failure. </dd></dl>

</div>
</div>
<a id="ga09eae83fe37c58957e50e8c808a030d2" name="ga09eae83fe37c58957e50e8c808a030d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09eae83fe37c58957e50e8c808a030d2">&#9670;&#160;</a></span>os_mqueue_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_mqueue_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *&#160;</td>
          <td class="paramname"><em>mq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove and return a single mbuf from the mbuf queue. Does not block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>The mbuf queue to pull an element off of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next mbuf in the queue, or NULL if queue has no mbufs. </dd></dl>

</div>
</div>
<a id="ga58e43a9a31ec5b87045c3fdac558c595" name="ga58e43a9a31ec5b87045c3fdac558c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e43a9a31ec5b87045c3fdac558c595">&#9670;&#160;</a></span>os_mqueue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mqueue_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *&#160;</td>
          <td class="paramname"><em>mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ble_npl_event_fn *&#160;</td>
          <td class="paramname"><em>ev_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an mqueue. An mqueue is a queue of mbufs that ties to a particular task's event queue. Mqueues form a helper API around a common paradigm: wait on an event queue until at least one packet is available, then process a queue of packets.</p>
<p>When mbufs are available on the queue, an event OS_EVENT_T_MQUEUE_DATA will be posted to the task's mbuf queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>The mqueue to initialize </td></tr>
    <tr><td class="paramname">ev_cb</td><td>The callback to associate with the mqeueue event. Typically, this callback pulls each packet off the mqueue and processes them. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to associate with the mqueue event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure. </dd></dl>

</div>
</div>
<a id="gab6e4cb29efbe140680667e3c8e907fd3" name="gab6e4cb29efbe140680667e3c8e907fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6e4cb29efbe140680667e3c8e907fd3">&#9670;&#160;</a></span>os_mqueue_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mqueue_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *&#160;</td>
          <td class="paramname"><em>mq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ble_npl_eventq *&#160;</td>
          <td class="paramname"><em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a packet (i.e. packet header mbuf) to an mqueue. The event associated with the mqueue gets posted to the specified eventq.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>The mbuf queue to append the mbuf to. </td></tr>
    <tr><td class="paramname">evq</td><td>The event queue to post an event to. </td></tr>
    <tr><td class="paramname">m</td><td>The mbuf to append to the mbuf queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure. </dd></dl>

</div>
</div>
<a id="ga82ba13b28a45ee54405dd7c4d6ea013b" name="ga82ba13b28a45ee54405dd7c4d6ea013b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82ba13b28a45ee54405dd7c4d6ea013b">&#9670;&#160;</a></span>os_msys_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_msys_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of blocks in all the mbuf pools that are allocated.</p>
<dl class="section return"><dt>Returns</dt><dd>total number of blocks allocated in Msys </dd></dl>

</div>
</div>
<a id="gaa37fae8ba05975e958dd7e30e4218a0f" name="gaa37fae8ba05975e958dd7e30e4218a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37fae8ba05975e958dd7e30e4218a0f">&#9670;&#160;</a></span>os_msys_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_msys_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>leadingspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a mbuf from msys. Based upon the data size requested, <a class="el" href="group___o_s_mbuf.html#gaa37fae8ba05975e958dd7e30e4218a0f">os_msys_get()</a> will choose the mbuf pool that has the best fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsize</td><td>The estimated size of the data being stored in the mbuf </td></tr>
    <tr><td class="paramname">leadingspace</td><td>The amount of leadingspace to allocate in the mbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A freshly allocated mbuf on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="gadbcbeb3a8fc23a871ed4f1fed560ed4d" name="gadbcbeb3a8fc23a871ed4f1fed560ed4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbcbeb3a8fc23a871ed4f1fed560ed4d">&#9670;&#160;</a></span>os_msys_get_pkthdr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> * os_msys_get_pkthdr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>user_hdr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a packet header structure from the MSYS pool. See <a class="el" href="group___o_s_mbuf.html#ga164e3f90cdee2692a85c249761ba001e">os_msys_register()</a> for a description of MSYS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsize</td><td>The estimated size of the data being stored in the mbuf </td></tr>
    <tr><td class="paramname">user_hdr_len</td><td>The length to allocate for the packet header structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A freshly allocated mbuf on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="gadf2b97336a5ab02260a304188374d345" name="gadf2b97336a5ab02260a304188374d345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf2b97336a5ab02260a304188374d345">&#9670;&#160;</a></span>os_msys_num_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_msys_num_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of free blocks in Msys</p>
<dl class="section return"><dt>Returns</dt><dd>Number of free blocks available in Msys </dd></dl>

</div>
</div>
<a id="ga164e3f90cdee2692a85c249761ba001e" name="ga164e3f90cdee2692a85c249761ba001e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164e3f90cdee2692a85c249761ba001e">&#9670;&#160;</a></span>os_msys_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_msys_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"><em>new_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MSYS is a system level mbuf registry. Allows the system to share packet buffers amongst the various networking stacks that can be running simultaeneously.</p>
<p>Mbuf pools are created in the system initialization code, and then when a mbuf is allocated out of msys, it will try and find the best fit based upon estimated mbuf size.</p>
<p><a class="el" href="group___o_s_mbuf.html#ga164e3f90cdee2692a85c249761ba001e">os_msys_register()</a> registers a mbuf pool with MSYS, and allows MSYS to allocate mbufs out of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_pool</td><td>The pool to register with MSYS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure </dd></dl>

</div>
</div>
<a id="gaa984a74000da6f436912a99821baeb9a" name="gaa984a74000da6f436912a99821baeb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa984a74000da6f436912a99821baeb9a">&#9670;&#160;</a></span>os_msys_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_msys_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-registers all mbuf pools from msys. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
